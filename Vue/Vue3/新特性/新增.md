## 一、异步组件

> * 使用**`defineAsyncComponent`** 方法定义异步组件
>
> - **`component` **选项被重命名为 **`loader`**
>
> - 与 2.x 不同，Loader 函数本身**不再接收 `resolve` 和 `reject`** 参数，且**必须返回一个 Promise**
>
>   ```js
>   // 2.x 版本
>   const oldAsyncComponent = (resolve, reject) => {
>     /* ... */
>   }
>   
>   // 3.x 版本
>   const asyncComponent = defineAsyncComponent(
>     () =>
>       new Promise((resolve, reject) => {
>         /* ... */
>       })
>   )
>   ```

### Vue 2.x

异步组件是通过将组件定义为返回 Promise 的函数来创建的，如：

```js
const asyncModal = () => import('./Modal.vue')
```

或者，对于带有选项的更高阶的组件语法：

```js
const asyncModal = {
  component: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  error: ErrorComponent,
  loading: LoadingComponent
}
```

### Vue 3.x

> 在 Vue 3 中，由于函数式组件被定义为纯函数，因此异步组件需要通过将其包裹在 **`defineAsyncComponent`** 方法中来定义：

```js
import { defineAsyncComponent } from 'vue'
import ErrorComponent from './components/ErrorComponent.vue'
import LoadingComponent from './components/LoadingComponent.vue'

// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() => import('./Modal.vue'))

// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})
```

