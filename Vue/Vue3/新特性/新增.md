## 一、异步组件

> * 使用**`defineAsyncComponent`** 方法定义异步组件
>
> - **`component` **选项被重命名为 **`loader`**
>
> - 与 2.x 不同，Loader 函数本身**不再接收 `resolve` 和 `reject`** 参数，且**必须返回一个 Promise**
>
>   ```js
>   // 2.x 版本
>   const oldAsyncComponent = (resolve, reject) => {
>     /* ... */
>   }
>     
>   // 3.x 版本
>   const asyncComponent = defineAsyncComponent(
>     () =>
>       new Promise((resolve, reject) => {
>         /* ... */
>       })
>   )
>   ```

### Vue 2.x

异步组件是通过将组件定义为返回 Promise 的函数来创建的，如：

```js
const asyncModal = () => import('./Modal.vue')
```

或者，对于带有选项的更高阶的组件语法：

```js
const asyncModal = {
  component: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  error: ErrorComponent,
  loading: LoadingComponent
}
```

### Vue 3.x

> 在 Vue 3 中，由于函数式组件被定义为纯函数，因此异步组件需要通过将其包裹在 **`defineAsyncComponent`** 方法中来定义：

```js
import { defineAsyncComponent } from 'vue'
import ErrorComponent from './components/ErrorComponent.vue'
import LoadingComponent from './components/LoadingComponent.vue'

// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() => import('./Modal.vue'))

// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})
```

## 二、组件`emits`选项

> **`emits`** 选项，和现有的 **`props`** 选项类似。这个选项可以用来定义一个组件可以向其父组件触发的事件。
>
> 并且，`emits` 选项中列出的事件**不会**从组件的根元素继承，也将从 **`$attrs`** property 中移除，否则将随 **`$attrs`** 绑定到组件的根节点上

emits 可以是数组或对象，从组件触发自定义事件，emits 可以是简单的数组，也可以是对象，后者允许配置事件验证。

在对象语法中，每个 property 的值可以为 `null` 或验证函数。验证函数将接收传递给 `$emit` 调用的其他参数。如果 `this.$emit('foo',1)` 被调用，`foo` 的相应验证函数将接收参数 `1`。验证函数应返回布尔值，以表示事件参数是否有效。

```js
const app = createApp({})

// 数组语法
app.component('todo-item', {
  emits: ['check'],
  created() {
    this.$emit('check')
  }
})

// 对象语法
app.component('reply-form', {
  emits: {
    // 没有验证函数
    click: null,
    // 带有验证函数
    submit: payload => {
      if (payload.email && payload.password) {
        return true
      } else {
        console.warn(`Invalid submit event payload!`)
        return false
      }
    }
  }
})
```

对于向其父组件透传原生事件的组件来说，这会导致有两个事件被触发：

```vue
<template>
  <button v-on:click="$emit('click', $event)">OK</button>
</template>
<script>
export default {
  emits: [] // 不声明事件
}
</script>
```

当一个父级组件拥有 `click` 事件的监听器时：

```html
<my-button v-on:click="handleClick"></my-button>
```

该事件现在会被触发*两次*:

- 一次来自 `$emit()`。
- 另一次来自应用在根元素上的原生事件监听器。

## 三、组件 `expose` 选项

> - 一个将暴露在公共组件实例上的 property 列表。
>
>   默认情况下，通过 [`$refs`](https://v3.cn.vuejs.org/api/instance-properties.html#refs)、[`$parent`](https://v3.cn.vuejs.org/api/instance-properties.html#parent) 或 [`$root`](https://v3.cn.vuejs.org/api/instance-properties.html#root) 访问到的公共实例与模板使用的组件内部实例是一样的。`expose` 选项将限制公共实例可以访问的 property。
>
>   由 Vue 自身定义的 property，比如 `$el` 和 `$parent`，将始终可以被公共实例访问，并不需要列出。

```js
export default {
  // increment 将被暴露，
  // 但 count 只能被内部访问
  expose: ['increment'],

  data() {
    return {
      count: 0
    }
  },

  methods: {
    increment() {
      this.count++
    }
  }
}
```

