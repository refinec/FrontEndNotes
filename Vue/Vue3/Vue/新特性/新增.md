## 一、异步组件 defineAsyncComponent

> * 使用**`defineAsyncComponent`** 方法定义异步组件
>
> - **`component` **选项被重命名为 **`loader`**
>
> - 与 2.x 不同，Loader 函数本身**不再接收 `resolve` 和 `reject`** 参数，且**必须返回一个 Promise**
>
>   ```js
>   // 2.x 版本
>   const oldAsyncComponent = (resolve, reject) => {
>     /* ... */
>   }
>         
>   // 3.x 版本
>   const asyncComponent = defineAsyncComponent(
>     () =>
>       new Promise((resolve, reject) => {
>         resolve({
>           template: '<div>I am async!</div>'
>         })
>         // 也可以调用 reject(reason)，来表示加载失败
>         /* ... */
>       })
>   )
>   ```

### Vue 2.x

异步组件是通过将组件定义为返回 Promise 的函数来创建的，如：

```js
const asyncModal = () => import('./Modal.vue')
```

或者，对于带有选项的更高阶的组件语法：

```js
const asyncModal = {
  component: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  error: ErrorComponent,
  loading: LoadingComponent
}
```

### Vue 3.x

> 在 Vue 3 中，由于函数式组件被定义为纯函数，因此异步组件需要通过将其包裹在 **`defineAsyncComponent`** 方法中来定义：

```js
import { defineAsyncComponent } from 'vue'
import ErrorComponent from './components/ErrorComponent.vue'
import LoadingComponent from './components/LoadingComponent.vue'

// 不带选项的异步组件
const asyncModal = defineAsyncComponent(() => import('./Modal.vue'))

// 带选项的异步组件
const asyncModalWithOptions = defineAsyncComponent({
  loader: () => import('./Modal.vue'),
  delay: 200,
  timeout: 3000,
  errorComponent: ErrorComponent,
  loadingComponent: LoadingComponent
})
```

**与 Suspense 一起使用**

异步组件在默认情况下是*可挂起*的。这意味着如果它在父链中有一个 `<Suspense>`，它将被视为该 `<Suspense>` 的异步依赖。在这种情况下，加载状态将由 `<Suspense>` 控制，组件自身的加载、错误、延迟和超时选项都将被忽略。

通过在其选项中指定 **`suspensible: false`**，异步组件可以退出 `Suspense` 控制，并始终控制自己的加载状态。

## 二、组件`emits`选项

> **`emits`** 选项，和现有的 **`props`** 选项类似。这个选项可以用来定义一个组件可以向其父组件触发的事件。
>
> 并且，`emits` 选项中列出的事件**不会**从组件的根元素继承，也将从 **`$attrs`** property 中移除，否则将随 **`$attrs`** 绑定到组件的根节点上

emits 可以是数组或对象，从组件触发自定义事件，emits 可以是简单的数组，也可以是对象，后者允许配置事件验证。

在对象语法中，每个 property 的值可以为 `null` 或验证函数。验证函数将接收传递给 `$emit` 调用的其他参数。如果 `this.$emit('foo',1)` 被调用，`foo` 的相应验证函数将接收参数 `1`。验证函数应返回布尔值，以表示事件参数是否有效。

```js
const app = createApp({})

// 数组语法
app.component('todo-item', {
  emits: ['check'],
  created() {
    this.$emit('check')
  }
})

// 对象语法
app.component('reply-form', {
  emits: {
    // 没有验证函数
    click: null,
    // 带有验证函数
    submit: payload => {
      if (payload.email && payload.password) {
        return true
      } else {
        console.warn(`Invalid submit event payload!`)
        return false
      }
    }
  }
})
```

对于向其父组件透传原生事件的组件来说，这会导致有两个事件被触发：

```vue
<template>
  <button v-on:click="$emit('click', $event)">OK</button>
</template>
<script>
export default {
  emits: [] // 不声明事件
}
</script>
```

当一个父级组件拥有 `click` 事件的监听器时：

```html
<my-button v-on:click="handleClick"></my-button>
```

该事件现在会被触发*两次*:

- 一次来自 `$emit()`。
- 另一次来自应用在根元素上的原生事件监听器。

## 三、组件 `expose` 选项

> - 一个将暴露在公共组件实例上的 property 列表。
>
>   默认情况下，通过 [`$refs`](https://v3.cn.vuejs.org/api/instance-properties.html#refs)、[`$parent`](https://v3.cn.vuejs.org/api/instance-properties.html#parent) 或 [`$root`](https://v3.cn.vuejs.org/api/instance-properties.html#root) 访问到的公共实例与模板使用的组件内部实例是一样的。`expose` 选项将限制公共实例可以访问的 property。
>
>   由 Vue 自身定义的 property，比如 `$el` 和 `$parent`，将始终可以被公共实例访问，并不需要列出。

```js
export default {
  // increment 将被暴露，
  // 但 count 只能被内部访问
  expose: ['increment'],

  data() {
    return {
      count: 0
    }
  },

  methods: {
    increment() {
      this.count++
    }
  }
}
```

## 四、片段

### Vue 2.x

在 2.x 中，由于不支持多根节点组件，许多组件被包裹在了一个 `<div>` 中。

一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 [props](https://v3.cn.vuejs.org/guide/component-props.html) 或 [emits](https://v3.cn.vuejs.org/guide/component-custom-events.html#定义自定义事件) 定义的 attribute。常见的示例包括 `class`、`style` 和 `id` attribute。可以通过 `$attrs` property 访问那些 attribute。

1. 当组件返回单个根节点时，非 prop 的 attribute 将默认自动添加到根节点的 attribute 中。

2. 如果你**不**希望组件的根元素继承 attribute，可以在组件的选项中设置 `inheritAttrs: false`。

   禁用 attribute 继承的常见场景是需要将 attribute 应用于根节点之外的其他元素。

### Vue 3.x

在 3.x 中，组件可以包含多个根节点！但是，这要求开发者显式定义 attribute 应该分布在哪里。

```html
<!-- Layout.vue -->
<template>
  <header>...</header>
  <main v-bind="$attrs">...</main>
  <footer>...</footer>
</template>
```

## 五、suspense ([API 可能随时会发生变动](https://v3.cn.vuejs.org/guide/migration/suspense.html))

> 在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。
>
> **该 `<suspense>` 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中**。

```vue
<template>
  <suspense>
    <!-- <suspense> 组件有两个插槽。它们都只接收一个直接子节点  -->
    <!-- default 插槽里的节点会尽可能展示出来。如果不能，则展示 fallback 插槽里的节点 -->
    <template #default>
      <todo-list />
    </template>
    <template #fallback>
      <div>
        Loading...
      </div>
    </template>
  </suspense>
</template>
<script>
export default {
  components: {
    TodoList: defineAsyncComponent(() => import('./TodoList.vue'))
  }
}
</script>
```

重要的是，异步组件不需要作为 `<suspense>` 的直接子节点。它可以出现在组件树任意深度的位置，且不需要出现在和 `<suspense>` 自身相同的模板中。只有所有的后代组件都准备就绪，该内容才会被认为解析完毕。

另一个**触发 `fallback` 的方式是让后代组件从 `setup` 函数中返回一个 Promise**。通常这是通过 **`async`** 实现的，而不是显式地返回一个 Promise：

```js
export default {
  async setup() {
    // 在 `setup` 内部使用 `await` 需要非常小心
    // 因为大多数组合式 API 函数只会在
    // 第一个 `await` 之前工作
    const data = await loadData()

    // 它隐性地包裹在一个 Promise 内
    // 因为函数是 `async` 的
    return {
      // ...
    }
  }
}
```

### 子组件更新

一旦 `<suspense>` 的 `default` 插槽里的内容被解析，则它只有在 `default` 根结点被替换的时候才能被再次触发。而树里的深层嵌套组件不足以让 `<suspense>` 回到等待状态。

如果根结点发生了变化，它会触发 `pending` 事件。然而，默认情况下，它不会更新 DOM 以展示 `fallback` 内容。取而代之的是，它会继续展示旧的 DOM，直到新组件准备就绪。这个行为可以通过 **`timeout`** prop 进行控制( **defineAsyncComponent组件的timeout** )。这个值是一个毫秒数，告诉 `<suspense>` 组件多久之后展示 `fallback`。如果这个值是 `0` 则表示它在 `<suspense>` 进入等待状态时会立即显示。

### 事件

除了 `pending` 事件以外，`<suspense>` 组件还拥有 `resolve` 和 `fallback` 事件。`resolve` 事件会在 `default` 插槽完成新内容的解析之后被触发。`fallback` 事件会在 `fallback` 插槽的内容展示的时候被触发。

**这些事件可以用在诸如当新组件加载时在旧 DOM 上展示一个加载标识等场景**

### 和其它组件结合

将 `<suspense>` 跟 [``](https://v3.cn.vuejs.org/api/built-in-components.html#transition) 和 [``](https://v3.cn.vuejs.org/api/built-in-components.html#keep-alive) 组件相结合是常见的情形。这些组件的嵌套顺序对于它们的正确工作很重要。

额外的，这些组件经常用于衔接 [Vue Router](https://next.router.vuejs.org/zh/) 的 `<router-view>` 组件。

以下示例展示了如何嵌套这些组件以让它们的表现符合预期。若要简化这个组合你可以移除不需要的组件：

```html
<router-view v-slot="{ Component }">
  <template v-if="Component">
    <transition mode="out-in">
      <keep-alive>
        <suspense>
          <component :is="Component"></component>
          <template #fallback>
            <div>
              Loading...
            </div>
          </template>
        </suspense>
      </keep-alive>
    </transition>
  </template>
</router-view>
```

Vue Router 有内置的基于动态导入的[组件懒加载](https://next.router.vuejs.org/zh/guide/advanced/lazy-loading.html)支持。它和异步组件有所区别，并且当前不会触发 `<suspense>`。不过它们仍然可以包含异步组件作为后代，这样它们还是可以正常触发 `<suspense>`。

### 用 `onErrorCaptured` 捕获 `suspense`中出现的错误

```vue
<script>
	import { ref,onErrorCaptured } from 'vue';
  setup() {
    const captureError = ref(null);
      onErrorCaptured((e: any) => { // 捕获suspense中可能的错误
        captureError.value = e;
        return true; // 返回一个布尔值，表示是否继续向上传播
      })
    return {
      captureError
    }
  }
</script>
```

## 六、Teleport 组件

> 有时组件模板的一部分逻辑上属于该组件，而从技术角度来看，最好将模板的这一部分移动到 DOM 中 Vue app 之外的其他位置

### props

- **to - `string`**

  > 需要 prop，必须是有效的查询选择器或 HTMLElement (如果在浏览器环境中使用)。指定将在其中移动 `<teleport>` 内容的目标元素

  ```html
  <!-- 正确 -->
  <teleport to="#some-id" />
  <teleport to=".some-class" />
  <teleport to="[data-teleport]" />
  
  <!-- 错误 -->
  <teleport to="h1" />
  <teleport to="some-string" />
  ```

- **disabled - `boolean`**

  > 此可选属性可用于禁用 `<teleport>` 的功能，这意味着其插槽内容将不会移动到任何位置，而是在你在周围父组件中指定了 `<teleport>` 的位置渲染。

  ```html
  <teleport to="#popup" :disabled="displayVideoInline">
    <video src="./my-movie.mp4">
  </teleport>
  ```

Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。

让我们修改 `modal-button` 以使用 `<teleport>`，并告诉 Vue “将这个 HTML **传送**到‘**body**’标签下”。

```js
app.component('modal-button', {
  template: `
    <button @click="modalOpen = true">
        Open full screen modal! (With teleport!)
    </button>

    <teleport to="body">
      <div v-if="modalOpen" class="modal">
        <div>
          I'm a teleported modal! 
          (My parent is "body")
          <button @click="modalOpen = false">
            Close
          </button>
        </div>
      </div>
    </teleport>
  `,
  data() {
    return { 
      modalOpen: false
    }
  }
})
```

### 在同一目标上使用多个 teleport

一个常见的用例场景是一个可重用的 `<Modal>` 组件，它可能同时有多个实例处于活动状态。对于这种情况，多个 `<teleport>` 组件可以将其内容挂载到同一个目标元素。顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后。

```html
<teleport to="#modals">
  <div>A</div>
</teleport>
<teleport to="#modals">
  <div>B</div>
</teleport>

<!-- result-->
<div id="modals">
  <div>A</div>
  <div>B</div>
</div>
```
