## 一、 v-for 中的 Ref 数组

### Vue 2.x

> 在 Vue 2 中，在 `v-for` 中使用的 `ref` attribute 会用 ref 数组填充相应的 `$refs` property

```vue
<template>
	<div v-for="item in list" ref="setItemRef"></div>
<template>
<script>
  export default {
    methods: {
      ItemRef() {
        console.log(this.$refs.setItemRef); // [div, div, div, ...]
      }
    }
  }
</script>
```

###  Vue 3.x

> 在 Vue 3 中，此类用法将不再自动创建 `$ref` 数组。要从单个绑定获取多个 ref，将 `ref` 绑定到函数上

**注意**：

- `itemRefs` 不必是数组：它也可以是一个对象，其 ref 可以通过迭代的 key 被设置。
- 如有需要，`itemRefs` 也可以是响应式的，且可以被侦听。

```vue
<template>
	<div v-for="item in list" :ref="setItemRef"></div>
<template>
```

```vue
<!-- 结合选项式 API -->
<script>
	export default {
  data() {
    return {
      itemRefs: []
    }
  },
  methods: {
    setItemRef(el) {
      if (el) {
        this.itemRefs.push(el)
      }
    }
  },
  beforeUpdate() {
    this.itemRefs = []
  },
  updated() {
    console.log(this.itemRefs) // Proxy {0: div, 1: div, .....}
  }
}
</script>
```

```vue
<!-- 结合组合式 AP -->
import { onBeforeUpdate, onUpdated } from 'vue'

export default {
  setup() {
    let itemRefs = []
    const setItemRef = el => {
      if (el) {
        itemRefs.push(el)
      }
    }
    onBeforeUpdate(() => {
      itemRefs = []
    })
    onUpdated(() => {
      console.log(itemRefs)
    })
    return {
      setItemRef
    }
  }
}
```

## 二、插槽统一

> **移除** **`this.$scopedSlots`**
>
> 将所有 `this.$scopedSlots` 替换为 **`this.$slots`**
>
> 将所有 `this.$slots.mySlot` 替换为 **`this.$slots.mySlot()`**

### 1. Vue 2.x

当使用渲染函数，即 `h` 时，2.x 曾经在内容节点上定义 `slot` 数据 property。

```js
// 2.x 语法
h(LayoutComponent, [
  h('div', { slot: 'header' }, this.header),
  h('div', { slot: 'content' }, this.content)
])
```

此外，可以使用以下语法引用作用域插槽：

```js
// 2.x 语法
this.$scopedSlots.header
```

#### 元素渲染方面

```vue
<template slot="t1" slot-scope="scope">
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
<!-- 或者v-slot -->
<template v-slot:t1="scope"> <!-- 简写：#t1="scope" -->
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
```

### 2. Vue 3.x

在 3.x 中，插槽以对象的形式定义为当前节点的子节点：

```js
// 3.x Syntax
h(LayoutComponent, {}, {
  header: () => h('div', this.header),
  content: () => h('div', this.content)
})
```

当你需要以编程方式引用作用域插槽时，它们现在被统一到 `$slots` 选项中了。

```js
// 2.x 语法
this.$scopedSlots.header

// 3.x 语法
this.$slots.header()
```

#### 元素渲染方面

> 移除 **`slot`** 和 **`slot-scope`**,仅仅保留使用 **`v-slot`**

```vue
<template v-slot:t1="scope"> <!-- 简写：#t1="scope" -->
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
```

## 三、attribute 强制行为

### 2.x 和 3.x 行为的比较

| Attributes                                                   | `v-bind` 的值 2.x            | `v-bind` 的值 3.x   | HTML 输出 |
| ------------------------------------------------------------ | ---------------------------- | ------------------- | --------- |
| 2.x “枚举 attribute” 即 `contenteditable`、`draggable` 与 `spellcheck`。 | `undefined`                  | `undefined`, `null` | *被移除*  |
| `true`, `'true'`, `''`, `1`, `'foo'`                         | `true`, `'true'`             | `"true"`            |           |
| `null`, `false`, `'false'`                                   | `false`, `'false'`           | `"false"`           |           |
| 其他非布尔 attribute 如 `aria-checked`、`tabindex`、`alt` 等等。 | `undefined`, `null`, `false` | `undefined`, `null` | *被移除*  |
| `'false'`                                                    | `false`, `'false'`           | `"false"`           |           |

## 四、`$attrs`包含`class`&`style`

### Vue2.x

> `$attrs` 现在包含了*所有*传递给组件的 attribute，但不包括 **`class`** 和 **`style`**。

上述行为在使用 **`inheritAttrs: false`** 时会产生副作用：

- `$attrs` 中的 attribute 将不再被自动添加到根元素中，而是由开发者决定在哪添加。
- 但是 `class` 和 `style` 不属于 `$attrs`，它们仍然会被应用到组件的根元素中：

```vue
<template>
  <label>
    <input type="text" v-bind="$attrs" />
  </label>
</template>
<script>
export default {
  inheritAttrs: false
}
</script>
```

像这样使用时：

```html
<my-component id="my-id" class="my-class"></my-component>
```

将生成以下 HTML：

```html
<label class="my-class">
  <input type="text" id="my-id" />
</label>
```

### Vue3.x

> `$attrs` 现在包含了*所有*传递给组件的 attribute，包括 **`class`** 和 **`style`**。

`$attrs` 包含了*所有的* attribute，这使得把它们全部应用到另一个元素上变得更加容易了。现在上面的示例将生成以下 HTML：

```html
<label>
  <input type="text" id="my-id" class="my-class" />
</label>
```

## 五、自定义指令

### Vue 2.x

在 Vue 2 中，自定义指令通过使用下列钩子来创建，以对齐元素的生命周期，它们都是可选的：

- **bind** - 指令绑定到元素后调用。只调用一次。
- **inserted** - 元素插入父 DOM 后调用。
- **update** - 当元素更新，但子元素尚未更新时，将调用此钩子。
- **componentUpdated** - 一旦组件和子级被更新，就会调用这个钩子。
- **unbind** - 一旦指令被移除，就会调用这个钩子。也只调用一次。

#### **边界情况：访问组件实例**

在 Vue 2 中，必须通过 `vnode` 参数访问组件实例：

```js
bind(el, binding, vnode) {
  const vm = vnode.context
}
```

### Vue 3.x

> 在 Vue 3 中，统一生命周期

- **created** - 新增！在元素的 attribute 或事件监听器被应用之前调用。
- bind → **beforeMount**
- inserted → **mounted**
- **beforeUpdate**：新增！在元素本身被更新之前调用，与组件的生命周期钩子十分相似。
- update → 移除！该钩子与 `updated` 有太多相似之处，因此它是多余的。请改用 `updated`。
- componentUpdated → **updated**
- **beforeUnmount**：新增！与组件的生命周期钩子类似，它将在元素被卸载之前调用。
- unbind -> **unmounted**

最终的 API 如下：

```js
const MyDirective = {
  created(el, binding, vnode, prevVnode) {}, // 新增
  beforeMount() {},
  mounted() {},
  beforeUpdate() {}, // 新增
  updated() {},
  beforeUnmount() {}, // 新增
  unmounted() {}
}
```

示例：

```html
<p v-highlight="'yellow'">以亮黄色高亮显示此文本</p>
```

```js
const app = Vue.createApp({})

app.directive('highlight', {
  beforeMount(el, binding, vnode) {
    el.style.background = binding.value
  }
})
```

#### **边界情况：访问组件实例**

在 Vue 3 中，实例现在是 `binding` 参数的一部分：

```js
mounted(el, binding, vnode) {
  const vm = binding.instance
}
```

### 注意

> 有了[片段](https://v3.cn.vuejs.org/guide/migration/fragments.html#概览)的支持，组件可能会有多个根节点。当被应用于多根组件时，自定义指令将被忽略，并将抛出警告。

## 六、与自定义元素的互操作性

> - **非兼容**：检测并确定哪些标签应该被视为自定义元素的过程，现在会在模板编译期间执行，且应该通过编译器选项而不是运行时配置来配置。
> - **非兼容**：特殊的 `is` attribute 的使用被严格限制在保留的 `<component>` 标签中。
> - **新增**：为了支持 2.x 在原生元素上使用 `is` 的用例来处理原生 HTML 解析限制，我们用 `vue:` 前缀来解析一个 Vue 组件。

### 自主定制元素

想要在 Vue 外部定义添加自定义元素 (例如使用 Web Components API)，则需要“指示”Vue 将其视为自定义元素。让我们以下面的模板为例。

```html
<plastic-button></plastic-button>
```

#### Vue 2.x

在 Vue 2.x 中，通过 `Vue.config.ignoredElements` 将标签配置为自定义元素：

```js
// 这将使 Vue 忽略在其外部定义的自定义元素
// (例如：使用 Web Components API)

Vue.config.ignoredElements = ['plastic-button']
```

#### Vue 3.x

**在 Vue 3.0 中，此检查在模板编译期间执行**。要指示编译器将 `<plastic-button>` 视为自定义元素：

- 如果使用构建步骤：给 Vue 模板编译器传入 `isCustomElement` 选项。如果使用了 `vue-loader`，则应通过 `vue-loader` 的 `compilerOptions` 选项传递：

  ```js
  // webpack 中的配置
  rules: [
    {
      test: /\.vue$/,
      use: 'vue-loader',
      options: {
        compilerOptions: {
          isCustomElement: tag => tag === 'plastic-button'
        }
      }
    }
    // ...
  ]
  ```

- 如果使用动态模板编译，请通过 `app.config.compilerOptions.isCustomElement` 传递：

  ```js
  const app = Vue.createApp({})
  app.config.compilerOptions.isCustomElement = tag => tag === 'plastic-button'
  ```

### 定制内置元素 is属性

在 3.0 中，我们将 Vue 对 `is` attribute 的特殊处理限制在了 `<component>` 标签中。

- 在保留的 `<component>` 标签上使用时，它的行为将与 2.x 中完全相同；

- 在**普通组件**上使用时，它的行为将类似于普通 attribute：

  ```html
  <foo is="bar" />
  ```

  - 2.x 的行为：渲染 `bar` 组件。
  - 3.x 的行为：渲染 `foo` 组件，并将 `is` attribute 传递给它。

- 在**普通元素**上使用时，它将作为 `is` attribute 传递给 `createElement` 调用，并作为原生 attribute 渲染。这支持了自定义内置元素的用法。

  ```html
  <button is="plastic-button">点击我！</button>
  ```

  - 2.x 的行为：渲染 `plastic-button` 组件。

  - 3.x 的行为：通过调用以下函数渲染原生的 button

    ```js
    document.createElement('button', { is: 'plastic-button' })
    ```

### 使用 `vue:` 前缀来解决 <u>DOM 内模板解析</u> 问题

> 一些 HTML 元素，例如 `<ul>`、`<ol>`、`<table>` 和 `<select>` 对它们内部可以出现的元素有限制，以及一些像 `<li>`、`<tr>`、和 `<option>` 只能出现在特定的其他元素中。

#### Vue 2.x

在 Vue 2 中，在原生标签上使用 **`is`** attribute 来绕过这些限制：

```html
<table>
  <tr is="blog-post-row"></tr>
</table>
```

#### Vue 3.x

将元素解析为 Vue 组件需要添加一个 **`vue:`** 前缀：

```html
<table>
  <tr is="vue:blog-post-row"></tr>
</table>
```

## 七、Data 选项

### Data 声明

#### Vue 2.x

> 在 2.x 中，开发者可以通过 **`object`** 或者是 **`function`** 定义 `data` 选项。

```html
<!-- Object 声明 -->
<script>
  const app = new Vue({
    data: {
      apiKey: 'a1b2c3'
    }
  })
</script>

<!-- Function 声明 -->
<script>
  const app = new Vue({
    data() {
      return {
        apiKey: 'a1b2c3'
      }
    }
  })
</script>
```

#### Vue 3.x

> 在 3.x 中，`data` 选项已标准化为只接受返回 `object` 的 **`function`**。

### Mixin 合并行为变更

当来自组件的 `data()` 及其 mixin 或 extends 基类被合并时，合并操作现在将被*浅层次*地执行：

```js
const Mixin = {
  data() {
    return {
      user: {
        name: 'Jack',
        id: 1
      }
    }
  }
}

const CompA = {
  mixins: [Mixin],
  data() {
    return {
      user: {
        id: 2
      }
    }
  }
}
```

#### Vue 2.x

在 Vue 2.x 中，生成的 `$data` 是：

```json
{
  "user": {
    "id": 2,
    "name": "Jack"
  }
}
```

#### Vue 3.x

在 3.0 中，其结果将会是：

```json
{
  "user": {
    "id": 2
  }
}
```
