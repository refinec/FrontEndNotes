## 一、 v-for 中的 Ref 数组

### 1. Vue 2

> 在 Vue 2 中，在 `v-for` 中使用的 `ref` attribute 会用 ref 数组填充相应的 `$refs` property

```vue
<template>
	<div v-for="item in list" ref="setItemRef"></div>
<template>
<script>
  export default {
    methods: {
      ItemRef() {
        console.log(this.$refs.setItemRef); // [div, div, div, ...]
      }
    }
  }
</script>
```

### 2. Vue 3

> 在 Vue 3 中，此类用法将不再自动创建 `$ref` 数组。要从单个绑定获取多个 ref，将 `ref` 绑定到函数上

**注意**：

- `itemRefs` 不必是数组：它也可以是一个对象，其 ref 可以通过迭代的 key 被设置。
- 如有需要，`itemRefs` 也可以是响应式的，且可以被侦听。

```vue
<template>
	<div v-for="item in list" :ref="setItemRef"></div>
<template>
```

```vue
<!-- 结合选项式 API -->
<script>
	export default {
  data() {
    return {
      itemRefs: []
    }
  },
  methods: {
    setItemRef(el) {
      if (el) {
        this.itemRefs.push(el)
      }
    }
  },
  beforeUpdate() {
    this.itemRefs = []
  },
  updated() {
    console.log(this.itemRefs) // Proxy {0: div, 1: div, .....}
  }
}
</script>
```

```vue
<!-- 结合组合式 AP -->
import { onBeforeUpdate, onUpdated } from 'vue'

export default {
  setup() {
    let itemRefs = []
    const setItemRef = el => {
      if (el) {
        itemRefs.push(el)
      }
    }
    onBeforeUpdate(() => {
      itemRefs = []
    })
    onUpdated(() => {
      console.log(itemRefs)
    })
    return {
      setItemRef
    }
  }
}
```

## 二、插槽统一

> **移除** **`this.$scopedSlots`**
>
> 将所有 `this.$scopedSlots` 替换为 **`this.$slots`**
>
> 将所有 `this.$slots.mySlot` 替换为 **`this.$slots.mySlot()`**

### 1. Vue 2.x

当使用渲染函数，即 `h` 时，2.x 曾经在内容节点上定义 `slot` 数据 property。

```js
// 2.x 语法
h(LayoutComponent, [
  h('div', { slot: 'header' }, this.header),
  h('div', { slot: 'content' }, this.content)
])
```

此外，可以使用以下语法引用作用域插槽：

```js
// 2.x 语法
this.$scopedSlots.header
```

#### 元素渲染方面

```vue
<template slot="t1" slot-scope="scope">
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
<!-- 或者v-slot -->
<template v-slot:t1="scope"> <!-- 简写：#t1="scope" -->
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
```

### 2. Vue 3.x

在 3.x 中，插槽以对象的形式定义为当前节点的子节点：

```js
// 3.x Syntax
h(LayoutComponent, {}, {
  header: () => h('div', this.header),
  content: () => h('div', this.content)
})
```

当你需要以编程方式引用作用域插槽时，它们现在被统一到 `$slots` 选项中了。

```js
// 2.x 语法
this.$scopedSlots.header

// 3.x 语法
this.$slots.header()
```

#### 元素渲染方面

> 移除 **`slot`** 和 **`slot-scope`**,仅仅保留使用 **`v-slot`**

```vue
<template v-slot:t1="scope"> <!-- 简写：#t1="scope" -->
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
```

## 三、attribute 强制行为

### 2.x 和 3.x 行为的比较

| Attributes                                                   | `v-bind` 的值 2.x            | `v-bind` 的值 3.x   | HTML 输出 |
| ------------------------------------------------------------ | ---------------------------- | ------------------- | --------- |
| 2.x “枚举 attribute” 即 `contenteditable`、`draggable` 与 `spellcheck`。 | `undefined`                  | `undefined`, `null` | *被移除*  |
| `true`, `'true'`, `''`, `1`, `'foo'`                         | `true`, `'true'`             | `"true"`            |           |
| `null`, `false`, `'false'`                                   | `false`, `'false'`           | `"false"`           |           |
| 其他非布尔 attribute 如 `aria-checked`、`tabindex`、`alt` 等等。 | `undefined`, `null`, `false` | `undefined`, `null` | *被移除*  |
| `'false'`                                                    | `false`, `'false'`           | `"false"`           |           |

## 四、`$attrs`包含`class`&`style`

### Vue2.x

> `$attrs` 现在包含了*所有*传递给组件的 attribute，但不包括 **`class`** 和 **`style`**。

上述行为在使用 **`inheritAttrs: false`** 时会产生副作用：

- `$attrs` 中的 attribute 将不再被自动添加到根元素中，而是由开发者决定在哪添加。
- 但是 `class` 和 `style` 不属于 `$attrs`，它们仍然会被应用到组件的根元素中：

```vue
<template>
  <label>
    <input type="text" v-bind="$attrs" />
  </label>
</template>
<script>
export default {
  inheritAttrs: false
}
</script>
```

像这样使用时：

```html
<my-component id="my-id" class="my-class"></my-component>
```

将生成以下 HTML：

```html
<label class="my-class">
  <input type="text" id="my-id" />
</label>
```

### Vue3.x

> `$attrs` 现在包含了*所有*传递给组件的 attribute，包括 **`class`** 和 **`style`**。

`$attrs` 包含了*所有的* attribute，这使得把它们全部应用到另一个元素上变得更加容易了。现在上面的示例将生成以下 HTML：

```html
<label>
  <input type="text" id="my-id" class="my-class" />
</label>
```
