## 一、 v-for 中的 Ref 数组

### Vue 2.x

> 在 Vue 2 中，在 `v-for` 中使用的 `ref` attribute 会用 ref 数组填充相应的 `$refs` property

```vue
<template>
	<div v-for="item in list" ref="setItemRef"></div>
<template>
<script>
  export default {
    methods: {
      ItemRef() {
        console.log(this.$refs.setItemRef); // [div, div, div, ...]
      }
    }
  }
</script>
```

###  Vue 3.x

> 在 Vue 3 中，此类用法将不再自动创建 `$ref` 数组。要从单个绑定获取多个 ref，将 `ref` 绑定到函数上

**注意**：

- `itemRefs` 不必是数组：它也可以是一个对象，其 ref 可以通过迭代的 key 被设置。
- 如有需要，`itemRefs` 也可以是响应式的，且可以被侦听。

```vue
<template>
	<div v-for="item in list" :ref="setItemRef"></div>
<template>
```

```vue
<!-- 结合选项式 API -->
<script>
	export default {
  data() {
    return {
      itemRefs: []
    }
  },
  methods: {
    setItemRef(el) {
      if (el) {
        this.itemRefs.push(el)
      }
    }
  },
  beforeUpdate() {
    this.itemRefs = []
  },
  updated() {
    console.log(this.itemRefs) // Proxy {0: div, 1: div, .....}
  }
}
</script>
```

```vue
<!-- 结合组合式 AP -->
import { onBeforeUpdate, onUpdated } from 'vue'

export default {
  setup() {
    let itemRefs = []
    const setItemRef = el => {
      if (el) {
        itemRefs.push(el)
      }
    }
    onBeforeUpdate(() => {
      itemRefs = []
    })
    onUpdated(() => {
      console.log(itemRefs)
    })
    return {
      setItemRef
    }
  }
}
```

## 二、插槽统一

> **移除** **`this.$scopedSlots`**
>
> 将所有 `this.$scopedSlots` 替换为 **`this.$slots`**
>
> 将所有 `this.$slots.mySlot` 替换为 **`this.$slots.mySlot()`**

### 1. Vue 2.x

当使用渲染函数，即 `h` 时，2.x 曾经在内容节点上定义 `slot` 数据 property。

```js
// 2.x 语法
h(LayoutComponent, [
  h('div', { slot: 'header' }, this.header),
  h('div', { slot: 'content' }, this.content)
])
```

此外，可以使用以下语法引用作用域插槽：

```js
// 2.x 语法
this.$scopedSlots.header
```

#### 元素渲染方面

```vue
<template slot="t1" slot-scope="scope">
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
<!-- 或者v-slot -->
<template v-slot:t1="scope"> <!-- 简写：#t1="scope" -->
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
```

### 2. Vue 3.x

在 3.x 中，插槽以对象的形式定义为当前节点的子节点：

```js
// 3.x Syntax
h(LayoutComponent, {}, {
  header: () => h('div', this.header),
  content: () => h('div', this.content)
})
```

当你需要以编程方式引用作用域插槽时，它们现在被统一到 `$slots` 选项中了。

```js
// 2.x 语法
this.$scopedSlots.header

// 3.x 语法
this.$slots.header()
```

#### 元素渲染方面

> 移除 **`slot`** 和 **`slot-scope`**,仅仅保留使用 **`v-slot`**

```vue
<template v-slot:t1="scope"> <!-- 简写：#t1="scope" -->
	<div>
    具名插槽t1，数据{{scope.data}}
  </div>
</template>
```

## 三、attribute 强制行为

### 2.x 和 3.x 行为的比较

| Attributes                                                   | `v-bind` 的值 2.x            | `v-bind` 的值 3.x   | HTML 输出 |
| ------------------------------------------------------------ | ---------------------------- | ------------------- | --------- |
| 2.x “枚举 attribute” 即 `contenteditable`、`draggable` 与 `spellcheck`。 | `undefined`                  | `undefined`, `null` | *被移除*  |
| `true`, `'true'`, `''`, `1`, `'foo'`                         | `true`, `'true'`             | `"true"`            |           |
| `null`, `false`, `'false'`                                   | `false`, `'false'`           | `"false"`           |           |
| 其他非布尔 attribute 如 `aria-checked`、`tabindex`、`alt` 等等。 | `undefined`, `null`, `false` | `undefined`, `null` | *被移除*  |
| `'false'`                                                    | `false`, `'false'`           | `"false"`           |           |

## 四、`$attrs`包含`class`&`style`

### Vue2.x

> `$attrs` 现在包含了*所有*传递给组件的 attribute，但不包括 **`class`** 和 **`style`**。

上述行为在使用 **`inheritAttrs: false`** 时会产生副作用：

- `$attrs` 中的 attribute 将不再被自动添加到根元素中，而是由开发者决定在哪添加。
- 但是 `class` 和 `style` 不属于 `$attrs`，它们仍然会被应用到组件的根元素中：

```vue
<template>
  <label>
    <input type="text" v-bind="$attrs" />
  </label>
</template>
<script>
export default {
  inheritAttrs: false
}
</script>
```

像这样使用时：

```html
<my-component id="my-id" class="my-class"></my-component>
```

将生成以下 HTML：

```html
<label class="my-class">
  <input type="text" id="my-id" />
</label>
```

### Vue3.x

> `$attrs` 现在包含了*所有*传递给组件的 attribute，包括 **`class`** 和 **`style`**。

`$attrs` 包含了*所有的* attribute，这使得把它们全部应用到另一个元素上变得更加容易了。现在上面的示例将生成以下 HTML：

```html
<label>
  <input type="text" id="my-id" class="my-class" />
</label>
```

## 五、自定义指令

### Vue 2.x

在 Vue 2 中，自定义指令通过使用下列钩子来创建，以对齐元素的生命周期，它们都是可选的：

- **bind** - 指令绑定到元素后调用。只调用一次。
- **inserted** - 元素插入父 DOM 后调用。
- **update** - 当元素更新，但子元素尚未更新时，将调用此钩子。
- **componentUpdated** - 一旦组件和子级被更新，就会调用这个钩子。
- **unbind** - 一旦指令被移除，就会调用这个钩子。也只调用一次。

#### **边界情况：访问组件实例**

在 Vue 2 中，必须通过 `vnode` 参数访问组件实例：

```js
bind(el, binding, vnode) {
  const vm = vnode.context
}
```

### Vue 3.x

> 在 Vue 3 中，统一生命周期

- **created** - 新增！在元素的 attribute 或事件监听器被应用之前调用。
- bind → **beforeMount**
- inserted → **mounted**
- **beforeUpdate**：新增！在元素本身被更新之前调用，与组件的生命周期钩子十分相似。
- update → 移除！该钩子与 `updated` 有太多相似之处，因此它是多余的。请改用 `updated`。
- componentUpdated → **updated**
- **beforeUnmount**：新增！与组件的生命周期钩子类似，它将在元素被卸载之前调用。
- unbind -> **unmounted**

最终的 API 如下：

```js
const MyDirective = {
  created(el, binding, vnode, prevVnode) {}, // 新增
  beforeMount() {},
  mounted() {},
  beforeUpdate() {}, // 新增
  updated() {},
  beforeUnmount() {}, // 新增
  unmounted() {}
}
```

示例：

```html
<p v-highlight="'yellow'">以亮黄色高亮显示此文本</p>
```

```js
const app = Vue.createApp({})

app.directive('highlight', {
  beforeMount(el, binding, vnode) {
    el.style.background = binding.value
  }
})
```

#### **边界情况：访问组件实例**

在 Vue 3 中，实例现在是 `binding` 参数的一部分：

```js
mounted(el, binding, vnode) {
  const vm = binding.instance
}
```

### 注意

> 有了[片段](https://v3.cn.vuejs.org/guide/migration/fragments.html#概览)的支持，组件可能会有多个根节点。当被应用于多根组件时，自定义指令将被忽略，并将抛出警告。
