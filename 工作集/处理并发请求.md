## 处理并发请求

1. ```js
   const axios = require('axios');
   const axiosInstance = axios.create({
     maxConcurrent: 10, // 设置最大并发数
   });
   
   const urls = [...]; // 你的请求URL数组
   
   const requests = urls.map(url => axiosInstance.get(url));
   axios.all(requests)
     .then(axios.spread((...responses) => {
       const data = responses.map(response => response.data);
       console.log(data);
     }))
     .catch(error => console.error(error));
   ```

2. ```js
   const urlList = ["..."]; // 所有请求列表
   const pool = new Set(); // 正在进行中的请求
   const waitQueue = []; // 等待队列
   const request = (url) => {
     return new Promise((resolve, reject) => {
       // 最大并发数
       const isFull = pool.size >= 10;
       const fn = function() {
         return fetch(url)
           .then(resolve)
           .catch(reject)
           .finally(() => {
             pool.delete(fn);
             const next = waitQueue.shift();
             next && pool.add(next);
           	// 立刻在当前调用栈里执行下一个请求，可能造成同步递归，调用栈会随并发深度而增长（虽然 fetch 是异步的，但 Promise 回调里的逻辑仍然会压栈）
           	// next?.();
           	// 把下一个请求推迟到新的宏任务里执行，确保当前这一帧彻底结束后再启动下一轮，从而保证调用栈不会无限加深，也避免在极端情况下触发“Maximum call stack size exceeded”。
             setTimeout(() => next?.());
         	});
       }
       if (isFull) {
         waitQueue.push(fn)
       } else {
         pool.add(fn);
         fn()
       }
     })
   }
   for (let [index, url] of urlList.entries()) {
     request(url).then(() => console.log("完成:", index));
   }
   ```
   
   

**第三方工具库：**

1. [p-limit](https://github.com/sindresorhus/p-limit)