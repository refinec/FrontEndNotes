> 首屏加载优化（首次打开速度怎么变快）

## 如何衡量加载情况好了多少？

这需要通过指标来判断，首屏加载的指标如下：

1. `FP`(First Paint 首次绘制)

2. `FCP`(First contentful Paint 首次内容绘制)，FP 到 FCP 中间其实主要是 SPA 应用js执行，太慢就会白屏时间太长。这是衡量首屏加载情况好坏的<u>重要指标</u>。

   ```js
   const paintEntries = performance.getEntriesByType('paint');
   paintEntries.forEach((entry)=>{
   	console.log(`${entry.name}:${entry.startTime} ms`)
   })
   // 输出:
   // First Paint: xxx ms
   // First Contentful Paint: xxx ms
   ```

3. `FMP`(Frist Meaningful Paint 首次有效绘制)，主要内容呈现的时间。这是衡量首屏加载情况好坏的<u>首要指标</u>。

4. `LCP`(Largest Contentful Paint 最大内容绘制)，加载最大内容块呈现的时间。这是衡量首屏加载情况好坏的<u>首要指标</u>。

   ```js
   const observer = new PerformanceObserver((list) => {
     const entries = list.getEntries();
     entries.forEach((entry)=>{ 
       console.log('LCP:',entry.startTime,'ms');
     });
   });
   observer.observe({ type: "largest-contentful-paint", buffered: true })
   ```

   



5. `INP`(Interaction to Next Paint)

6. `TTI` 可交互时间，ssr

7. `TBT`(Total Blocking Time 阻塞时间从 FCP 到 TTI): 总阻塞时间

8. `CLS`(Cumulative Layout Shift 布局偏移): 布局偏移情况，重排 `reflow`

   ```js
   let clsValue =0;
   const observer = new PerformanceObserver((list)=>{
     list.getEntries().forEach((entry) => {
       if (!entry.hadRecentInput) { 
         clsValue += entry.value;
       }
     });
   });
   observer.observe({ type:"layout-shift", buffered: true });
   window.addEventListener('beforeunload',()=>{
   	console.log('cLs:',clsValue);
   });
   ```

9. `TTFB`(Time to First Byte):首字节到达时间，请求发出后到接收到数据中间的时间

   ```js
   const {timing }= performance;
   const ttfb = timing.responseStart - timing.requestStart;
   console.log('TTFB:', ttfb, 'ms');
   ```

   

Google 的 `“好(Good)”`、`“需要改进(Needs Improvement)”`和`“差(Poor)”`阈值用于将数据点分类为绿色、黄色和红色，用于对应的 `Web Vitals`。`“Needs improvement”` 在 `Sentry` 中被称为 `“Meh”`。

| Web Vital          | Good     | Meh      | Poor    |
| ------------------ | -------- | -------- | ------- |
| 最大内容绘制 (LCP) | <= 2.5s  | <= 4s    | > 4s    |
| 首次输入延迟 (FID) | <= 100ms | <= 300ms | > 300ms |
| 累积布局偏移 (CLS) | <= 0.1   | <= 0.25  | > 0.25  |
| 首次绘制 (FP)      | <= 1s    | <= 3s    | > 3s    |
| 首次内容绘制 (FCP) | <= 1s    | <= 3s    | > 3s    |
| 首字节时间 (TTFB)  | <= 100ms | <= 200ms | > 600ms |



使用window.performance 或 performanceObserve API 或 web-vital库。

Flink数据、数据落库（日志型数据用列式存储 clickhouse、Postgresal）

## 实施方案

1. 优化图片，Webp，图片压缩，图片尺寸(在合适的容器内用合适的尺寸图片 1倍2倍3倍图)

2. 字体瘦身，设计型产品，字体子集化(用了哪些字，就最后只生成对应字的字体文件，使用`Fontmin`库)
3. 懒加载资源，图片懒加载、js 异步加载
4. css、JavaScript 文件压缩，打包构建阶段完成(terser)
   代码压缩
   文件合并
   文件拆分
   Tree shaking
   动态加载
5. Gzip、Brotli
6. SSR（服务器端渲染）、SSG（静态站点生成器）是一种在构建时生成静态 HTML、CSS 和 JavaScript 文件的工具或框架。与传统的服务器端渲染（SSR）或客户端渲染（CSR）不同，SSG 在部署前就将所有页面预先生成，用户访问时直接返回静态文件，无需服务器实时渲染。
