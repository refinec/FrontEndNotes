## 传统`diff` 算法的瓶颈

传统 diff 算法通过`循环递归`对节点进行依次对比，将前后两棵树完全比对的算法的复杂程度为 O(n^3 )，其中 n 是树中元素的数量。 复杂度过高，如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。为了降低算法复杂度，React 的 diff 会预设三个限制和三个策略：

## 三个限制和三个策略

### 三个限制

为了降低算法复杂度，React 的 diff 会预设三个限制：

1. 只进行`同层比较`。

2. 通过`type`比较新旧节点不同。

   新旧节点的 `type` 不同，直接`删除`旧节点，`创建`新节点。如元素由 `div` 变为 `p`，React会`销毁`div及其子孙节点，并`新建`p及其子孙节点。

3. 通过 `key` 来`复用`节点。

### 三个策略

`diff` 算法主要遵循三个层级的优化策略:

1. `tree` 层级
2. `conponent` 层级
3. `element` 层级

#### `tree` 层级

只对`DOM`树中相同层级的节点进行比较，比较的是`type`改变(如`div`变为`p`)，比较过程中只进行`删除`、`创建`两种操作

#### `conponent` 层级

* 是同一个类的组件，继续`diff`运算
* 不是同一个类的组件，则`删除`旧组件(所有节点),`创建`新组件(所有节点)

#### `element` 层级

* 同一层级的节点各自拥有唯一的`key`作为标识，通过该`key`进行比较。

  > 通过 `key` 可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置

* 节点比较过程中只进行 `INSERT_MARKUP`(插入)、`MOVE_EXISTING` (移动) 和 `REMOVE_NODE` (删除)三种操作。

## `diff`过程

从 `diff` 的入口函数 `reconcileChildFibers` 出发，判断子元素的类型，若不是数组进入`单节点diff`，否则进入`多节点diff`

- `单节点diff`：先判断 `key` 是否相同，

  - 如果 `key` 相同，再看 `type`
    - `type` 相同，复用；
    - `type` 不同，全部删掉（包括它和它的兄弟元素，因为既然 key 一样，唯一的可能性都不能复用，则剩下的 fiber 都没有机会了）；
  - 如果 `key` 不同，只删除该`child`，再找到它的兄弟节点（`child.silbing`）的 `key`，直到找到`key`相同的节点，再同上操作

- `多节点diff`：归纳只有 3 种情况，`更新节点`、`增删节点`、`位置变化`，由于是单向的链表（`newChildren[0]`与`fiber`比较，

  `newChildren[1]`与`fiber.sibling`比较），所以不能像 vue 一样用双指针遍历，所以这里逻辑要经过两轮遍历：

  - 第一轮遍历：比较 `key`，
    - 可复用，继续遍历 (新节点 `i++`，老节点`child.silbing`)，
    - 不可复用，就停止第一轮遍历，进入第二轮遍历，有 2 种不可复用的情况：
      - `key` 不同，直接停止
      - `key` 相同，`type` 不同，标记删除，停止
  - 第二轮遍历：
    - 老节点遍历完了，新节点还有，则将剩下的新节点`插入`
    - 新节点遍历完了，老节点还有，则将剩下的老节点`删除`
    - 新老节点都还有，则`移动顺序`，规则：遍历新节点，每个新节点有 2 个 `index`，`oldIndex`表示它在旧节点的位置，`maxIndex`表示遍历中遇到的最大旧节点的位置（初始预设值为0，比较过程中改变）。
      - 当 `oldIndex>maxIndex` 时，将 `oldIndex` 的值赋值给 `maxIndex`
      - 当 `oldIndex=maxIndex` 时，不操作
      - 当 `oldIndex<maxIndex` 时，将`老节点`移动到 `maxIndex` 的位置

![img](../../assets/%E9%9D%A2%E8%AF%95/202303211512561.png)

<img src="../../assets/%E9%9D%A2%E8%AF%95/202303211419967.png" alt="img" style="zoom:67%;" />