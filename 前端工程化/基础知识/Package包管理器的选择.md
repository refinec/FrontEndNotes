## npm、pnpm、yarn三种包管理器有何区别？

* **npm**

  **特点** ：

  - **官方权威** ：作为 Node.js 的默认包管理工具，与 Node.js 深度集成，安装 Node.js 时自带，无需额外安装，几乎所有的 Node.js 库和框架都支持 npm，**社区资源丰富，生态庞大**，拥有全球最大的 JavaScript 包仓库，包含超过 200 万个包。
  - **功能丰富** ：提供了大量的命令选项，可以处理安装、发布、版本管理、脚本运行等任务，能满足开发者在项目开发中的各种常见需求。
  - **兼容性好** ：与各种 Node.js 工具和插件的兼容性高，且一直吸收社区优点进行优化，如引入锁文件 package-lock.json 来确保依赖的一致性，改进依赖解析算法加速安装等

  **缺点** ：

  - **安装速度较慢** ：尤其在有大量依赖项的项目中，相比 pnpm 和 yarn，其安装速度相对较慢，因为它通常是逐个安装依赖包。
  - **磁盘空间浪费** ：安装依赖时会在项目中存储每个依赖包的副本，导致磁盘空间浪费，对于多项目依赖同一个包的情况更为明显。
  - **依赖管理易出问题** ：早期版本依赖管理机制松散，易导致 “幽灵依赖” 和版本冲突问题，不过 7.0 版本之后引入工作区等功能有所改善

* **pnpm**

  - **特点** ：
    - **节省磁盘空间** ：采用中心化 store，利用硬链接和软链接技术，将相同依赖包共享到全局存储中，避免重复存储，可显著减少磁盘空间使用，尤其适合管理多个项目的团队。
    - **安装速度快** ：在多项目工作区中安装速度优势明显，且通过利用全局缓存加速包的安装过程，整体安装速度比 npm 和 yarn 更快。
    - **依赖管理严格** ：强制依赖树的完整性，避免了多个版本同一包的安装问题，从而解决了 “幽灵依赖” 问题，确保项目依赖的一致性和稳定性。
    - **兼容性好** ：支持 npm 和 yarn 的 package-lock.json 和 yarn.lock 文件，可以无缝地与这两者兼容。
  - **缺点** ：
    - **兼容性问题** ：尽管与 npm 和 yarn 兼容，但有时可能会遇到一些包和工具不兼容的问题。
    - **生态系统较新** ：相较于 npm 和 yarn，其社区和生态系统还不够成熟，某些工具和教程可能较少

* **yarn**

  **特点** ：

  - **安装速度快** ：通过**并行化依赖包的下载**和缓存机制大大提升了安装速度，尤其适合大型项目，可快速将项目安装完成，提高开发效率。
  - **离线缓存** ：会将所有安装的依赖包缓存在本地，确保下次安装时可以快速离线安装，即使在网络不稳定的情况下也能高效完成依赖安装。
  - **依赖版本锁定** ：默认使用 `yarn.lock `文件来锁定依赖版本，确保每次安装的依赖版本一致，避免了因依赖版本漂移导致的问题，保证了项目的可重复性。
  - **工作区支持** ：很早就支持了工作区功能，适合管理包含多个子项目的大型代码库，可方便地对多个子项目进行统一管理和操作

  **缺点** ：

  - **社区支持稍逊** ：尽管受到广泛欢迎，但整体社区支持和生态系统丰富度不如 npm。
  - **安装配置复杂** ：对于一些用户来说，需要单独配置，尤其是工作区的设置可能让新手感觉有些复杂

### 幽灵依赖问题

> 幽灵依赖，也被称为幻影依赖，是指项目中使用了一些没有被定义在其 `package.json` 文件中的包

1. **幽灵依赖的形成原因**

   - **包管理器的扁平化策略** ：npm 和 yarn 等包管理器采用扁平化安装策略，将所有依赖包尽可能地安装在项目的根 `node_modules` 目录下。这样，即使某个包是作为其他依赖的子依赖而被安装的，也会直接出现在项目的根 `node_modules` 中，从而使得项目可以直接引用它，而无需在 `package.json` 中显式声明。

   - **Node.js 的模块解析规则** ：Node.js 在加载模块时，会先在当前模块所在的目录下查找 `node_modules`，如果找不到，会逐级向上查找父目录下的 `node_modules`，直到找到为止。这种解析规则使得项目能够引用到位于上级目录中的依赖包，即使这些包并未被项目直接声明

2. **幽灵依赖可能导致的问题**

   - **依赖不兼容** ：由于幽灵依赖未在 `package.json` 中显式声明，当其父依赖更新时，可能会引入新的幽灵依赖版本。新版本的幽灵依赖可能与项目中其他依赖或代码不兼容，导致项目运行出错。

   - **依赖缺失** ：在开发环境中，项目可能依赖某些幽灵依赖，但在生产环境中，这些幽灵依赖可能不会被安装，因为它们未在 `package.json` 中声明。这会导致项目在生产环境中出现运行时错误。

   - **项目可维护性降低** ：幽灵依赖使得项目的依赖关系变得不明确和难以管理，增加了项目的复杂性。开发人员可能不清楚项目实际依赖了哪些包，这给项目的维护和升级带来了困难

3. **检测幽灵依赖的方法**

   - **使用 pnpm** ：pnpm 包管理工具通过其独特的安装策略，可以避免幽灵依赖的产生。它将每个依赖包安装在项目根目录下的 `node_modules/.pnpm` 文件夹中，并在根 `node_modules` 中创建符号链接。这样可以确保只有在 `package.json` 中显式声明的依赖才会被直接引用。

   - **使用 npm fund 命令** ：`npm fund` 命令可以列出项目中的所有依赖及其版本信息，包括幽灵依赖。通过检查命令输出，可以发现项目中是否存在未声明的依赖。

   - **使用第三方工具** ：一些第三方工具可以检测 JavaScript 项目中的幽灵依赖，例如 `depcheck` 。它通过分析项目的代码和 `package.json` 文件，找出未使用的依赖和未声明的依赖。



## 项目开发如何选择？

- **小型项目** ：可优先选择 `npm`，因其简单易用，配置方便，社区资源丰富，遇到问题时更容易找到解决方案。如果对安装速度有一定要求，也可选择 `yarn` 或 `pnpm`。
- **中型项目** ：若对安装速度和依赖一致性有较高要求，`yarn` 是较好的选择，其并行安装和锁文件机制可提升开发效率并确保项目稳定性。同时，也可考虑 `pnpm`，它在节省磁盘空间和依赖管理严格性方面表现出色。
- **大型项目及多项目工作区** ：`pnpm` 的优势更为明显，其节省磁盘空间、高效的工作空间管理和快速的安装速度，可帮助团队更好地管理复杂项目和多个项目，减少资源浪费和依赖冲突问题。`yarn` 也适合，但需注意配置工作区等复杂性问题。
- **对生态资源依赖度高的项目** ：`npm` 是首选，其拥有最庞大的社区和最丰富的包资源，几乎所有的` JavaScript` 开发者和项目都会使用 `npm`，可确保在项目开发中能方便地获取各种所需依赖。
- **对网络环境要求高的项目** ：在国内外网络环境中，如因网络限制导致 `npm` 安装速度缓慢，可考虑使用 `cnpm`（针对国内网络环境优化，安装速度较快），但要注意其与 `npm` 的差异和潜在问题

| 特点       | npm              | yarn             | pnpm             |
| ---------- | ---------------- | ---------------- | ---------------- |
| 安装速度   | 相对较慢         | 快               | 最快             |
| 版本控制   | 有               | 有               | 有               |
| 离线模式   | 不支持           | 支持             | 支持             |
| 并行下载   | 不支持           | 支持             | 支持             |
| 内存管理   | 一般             | 一般             | 更好             |
| 依赖项缓存 | 占用较多磁盘空间 | 占用较多磁盘空间 | 占用较少磁盘空间 |
| 兼容性     | 良好             | 良好             | 可能存在问题     |
| 社区支持   | 广泛支持         | 广泛支持         | 较新，支持较少   |