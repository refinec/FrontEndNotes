# react 组件生命周期

**常用生命周期图谱：**

![image-20220812181235316](../../../assets/react/image-20220812181235316.png)

**展示不常用生命周期图谱：**

![image-20220812181353550](../../../assets/react/image-20220812181353550.png)

## 挂载

当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：

1. **`constructor()`**
2. `static getDerivedStateFromProps()`
3. **`render()`**
4. **`componentDidMount()`**

### constructor(props)

```jsx
constructor(props) {
  super(props);
  // 不要在这里调用 this.setState()
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}
```

**注意📢**：

1. **如果不初始化 `state` 或不进行`方法绑定`，则不需要为 React 组件实现构造函数**

2. 在 React 组件挂载之前，会调用它的构造函数。在为 `React.Component` 子类实现构造函数时，应在其他语句之前调用 `super(props)`。否则，`this.props` 在构造函数中可能会出现未定义的 bug。

3. **避免将 props 的值复制给 state**，因为这么做毫无必要，同时还产生了 bug（更新 prop 中的 `color` 时，并不会影响 state），你可以直接使用 `this.props.color`

   ```jsx
   constructor(props) {
    super(props);
    // 不要这样做
    this.state = { color: props.color };
   }
   ```

### render()

> `render()` 方法是 class 组件中唯一一个必须实现的方法。

当 `render` 被调用时，它会检查 `this.props` 和 `this.state` 的变化并返回以下类型之一：

* **React 元素**

* **数组或 fragments**

  使得 render 方法可以返回多个元素。👉🏻参阅 [fragments](https://zh-hans.reactjs.org/docs/fragments.html) 文档

* **Portals**

  可以渲染子节点到不同的 DOM 子树中。👉🏻参阅 [portals](https://zh-hans.reactjs.org/docs/portals.html) 文档

* **字符串或数值类型**

  它们在 DOM 中会被渲染为文本节点。

* **布尔类型或 `null`**。

  什么都不渲染。（主要用于支持返回 `test && <Child />` 的模式，其中 test 为布尔类型。)

**注意📢**：

1. `render()` 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。

2. 如需与浏览器进行交互，请在 `componentDidMount()` 或其他生命周期方法中执行你的操作。
3. 如果 `shouldComponentUpdate()` 返回 **false**，则不会调用 `render()`。

### componentDidMount() 组件挂载

> `componentDidMount()` 会在组件挂载后（插入 DOM 树中）立即调用。

#### 用处

1. 网络请求获取数据
2. 获取DOM节点
3. 适合添加订阅（如果添加了订阅，不要忘记在 `componentWillUnmount()` 里取消订阅）

## 更新

当组件的 **props** 或 **state** 发生变化时会触发更新。组件更新的生命周期调用顺序如下：

1. `static getDerivedStateFromProps()`
2. `shouldComponentUpdate()`
3. **`render()`**
4. `getSnapshotBeforeUpdate()`
5. **`componentDidUpdate()`**

### componentDidUpdate(`prevProps`, `prevState`, `snapshot`) 组件更新

> `componentDidUpdate()` 会在更新后会被立即调用，首次渲染不会执行此方法。

**第三参数**(`snapshot`)：如果组件实现了 `getSnapshotBeforeUpdate()` 生命周期（不常用），则它的返回值将作为 `componentDidUpdate()` 的第三个参数 “`snapshot`” 参数传递。否则此参数将为 **`undefined`**。

### 用处

1. **DOM操作**（当组件更新后，可以在此处对 DOM 进行操作）

2. **网络请求**（如果你对更新前后的 **props** 进行了比较，也可以选择在此处进行网络请求）

   ```jsx
   componentDidUpdate(prevProps) {
     // 典型用法（不要忘记比较 props）：
     if (this.props.userID !== prevProps.userID) {
       this.fetchData(this.props.userID);
     }
   }
   ```

**注意📢**：

1. 在 `componentDidUpdate()` 中**直接调用 `setState()`**时，要注意**它必须被包裹在一个条件语句里**，正如上述的例子那样进行处理，否则会导致死循环，它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。
2. 如果 [`shouldComponentUpdate()`](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate) 返回值为 false，则不会调用 `componentDidUpdate()`

## 卸载

当组件从 DOM 中移除时会调用如下方法：

- **`componentWillUnmount()`**

## 错误处理

当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：

- `static getDerivedStateFromError()`
- `componentDidCatch()`

## 其他 APIs

组件还提供了一些额外的 API：

- `setState()`
- `forceUpdate()`

## class 属性

- `defaultProps`
- `displayName`

## 实例属性

- `props`
- `state`