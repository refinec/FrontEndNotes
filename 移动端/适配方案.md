## 一、移动端H5通过`lib-flexible`+`rem`自适应适配方案

### rem实际开发适配方案

- (1)按照设计稿与设备宽度的比例,动态计算并设置html根标签的`font-size`大小;
- (2)CSS中,设计稿元素的宽、高、相对位置等取值,按照同等比例换算为`rem`为单位的值;

| 技术方案1 |                          技术方案2                           |
| :-------: | :----------------------------------------------------------: |
| 媒体查询  | [lib-flexible](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Famfe%2Flib-flexible) |
|    rem    |                             rem                              |
|   less    |                       vscode插件cssrem                       |

**总结**:两种方案都可以，一般推荐第二种方案，更简单操作

#### 原理

手机淘宝团队出的简洁高效移动端适配库。它的原理是把当前设备划分为10等份,但是不同设备下,比例还是一致的。
 我们要做的,就是确定好我们当前设备的html文字大小就可以了，比如当前设计稿是750px,那么我们只需要把html文字大小设置为`75px(750px / 10)`就可以。里面页面元素rem值:`页面元素的px值/ 75`。 剩余的,让flexible.js来去算

#### 页面元素大小取值方法

* 最后的公式:`页面元素的rem值=页面元素值(px) / (屏幕宽度/划分的份数))`
* `屏幕宽度/划分的份数`就是html的 `font-size`的大小
* 或者:页面元素的rem值=`页面元素值(px) / html的font-size`字体大小

### 使用步骤

1. `index.js`中把当前设备划分为10等份：

   ```js
   // set 1rem = viewWidth / 10
   function setRemUnit () {
     const rem = docEl.clientWidth / 10
     docEl.style.fontSize = rem + 'px'
   }
   ```

2. ##### 设置`meta`标签

   ```html
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
   ```

3. 引入`lib-flexible`

4. 初始化style(这步可以不要)

   ```css
   <style>
     /* 如果屏幕超过了750px，那么我们就就按照750px设计稿来走，不会让页面超过750px ,使用媒体查询来设置*/
     @media screen and (min-width: 750px) {
       html {
         font-size: 75px !important;
       }
     }
     body {
       min-width: 320px;
       max-width: 750px;
      /* flexible.js把设计稿750px进行10等分，所以html文字大小设置为75px(750px/ 10)，页面元素rem值:页面元素的px值/ 75(750px/75)*/
       width: 10rem;
       margin: 0 auto;
     }
   </style>
   ```

### `lib-flexible`关键源码

```js
(function flexible (window, document) {
  var docEl = document.documentElement
  var dpr = window.devicePixelRatio || 1

  // adjust body font size
  function setBodyFontSize () {
    if (document.body) {
      document.body.style.fontSize = (12 * dpr) + 'px'
    }
    else {
      document.addEventListener('DOMContentLoaded', setBodyFontSize)
    }
  }
  setBodyFontSize();

  // set 1rem = viewWidth / 10
  function setRemUnit () {
    var rem = docEl.clientWidth / 10
    docEl.style.fontSize = rem + 'px'
  }

  setRemUnit()

  // reset rem unit on page resize
  window.addEventListener('resize', setRemUnit)
  window.addEventListener('pageshow', function (e) {
    if (e.persisted) {
      setRemUnit()
    }
  })

  // detect 0.5px supports
  if (dpr >= 2) {
    var fakeBody = document.createElement('body')
    var testElement = document.createElement('div')
    testElement.style.border = '.5px solid transparent'
    fakeBody.appendChild(testElement)
    docEl.appendChild(fakeBody)
    if (testElement.offsetHeight === 1) {
      docEl.classList.add('hairlines')
    }
    docEl.removeChild(fakeBody)
  }
}(window, document))
```

## 二、通过`vw`适配

1. 安装库[vw-layout](https://github.com/airen/vw-layout)

2. 如果您的项目使用了 webpack，您可以将关联的 PostCSS 插件配置添加到 `postcssrc.js` 文件中

   ```js
   module.exports = {
       "plugins": {
           "postcss-aspect-ratio-mini": {}, 
           "postcss-px-to-viewport": {
               viewportWidth: 750,      // (Number) The width of the viewport.
               viewportHeight: 1334,    // (Number) The height of the viewport.
               unitPrecision: 3,        // (Number) The decimal numbers to allow the REM units to grow to.
               viewportUnit: 'vw',      // (String) Expected units.
               selectorBlackList: ['.ignore', '.hairlines'],  // (Array) The selectors to ignore and leave as px.
               minPixelValue: 1,       // (Number) Set the minimum pixel value to replace.
               mediaQuery: false       // (Boolean) Allow px to be converted in media queries.
           }, 
           "postcss-viewport-units":{},
       }
   }
   ```

参考：https://www.w3cplus.com/mobile/vw-layout-in-vue.html