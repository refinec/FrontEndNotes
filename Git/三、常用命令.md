

## `git commit --amend`  修改上次 `commit` 信息

> 修改最近一次提交的 `commit` 文本信息

```sh
$ git commit --amend
# 或者
$ git commit --amend -m "重新提交的信息"
```

## `git stash` 暂时保存当前开发内容

> 比如某天你正在认真的开发需求中，测试过来找你让你帮忙看一个线上问题。此时，你代码也刚写了一半，不想提交，这时怎么办？
>
> 此时我们可以通过`git stash`来暂存我们代码，然后切换到线上环境分支排查问题，解决后，切换回之前分支执行`git stash pop`继续开发。

```sh
$ git stash save "未完成的功能" # 暂存在stash
$ git stash pop # 取出第一个stash
```

### `git stash` 的常用操作

```shell
# 保存到stash栈中，并加上自定义message修饰
$ git stash save "message"

# 列出stash栈中所有元素
$ git stash list

# 应用stash栈中的第x个元素，pop是应用的同时且从栈中删除，而apply则是只应用不删除
$ git stash apply stash@{x}

# 删除stash栈中的第x个元素
$ git stash drop stash@{x}
```





## `git rebase` 变基(合并)分支 

> `rebase`同`merge`一样，可以合并分支。但有所区别：
>
> 1. `merge`不会破坏原分支的提交历史，方便回溯和查看。但会产生额外的提交节点，分支图比较复杂。
> 2. `rebase`不会新增额外的提交记录，形成线性历史，直观且干净。但会改变提交历史，改变了当前分支`branch out`的节点，**应避免在共享分支使用**。

在不同的分支上执行`git rebase`，变基的方向也不同。如下图：

1. 在`dev`分支上变基到`main`主分支上时，git会先找到它们公共的祖先节点即`main:3`节点，再把`dev:1`和`dev:2`两个节点嫁接到`main`主分支上。
2. 在`main`主分支上变基到`dev`分支上时，git会先找到它们公共的祖先节点即`main:3`节点，再把`main:4`和`main:5`两个节点嫁接到`dev`分支上。

![image-20231230220257158](../assets/github/image-20231230220257158.png)



## `git revert` 回滚版本

> `revert`命令会在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化。它不会改变过去的历史，所以是首选方式，没有任何丢失代码的风险。
>
> `revert`可以抵消上一个提交，那么如果想要抵消多个需要执行 `git revert 倒数第一个commit id 倒数第二个commit`
>
> 还有一种情景是已经有很多人提交过代码，但是想改之前的某一次`commit`记录又不想影响后面的也可以使用`revert`，他会把你后面提交的记录都放到工作区只是合并的时候需要注意一点

**操作一下revert来感受一下**

1. 如现在该分支有三个`commit`记录

   <img src="../assets/github/image-20220626180932020.png" alt="image-20220626180932020" style="zoom:67%;" />

2. 接着执行`git revert 16083ce`进行回滚，打开`VS Code`可以看到工作区的变化，并且在控制台可以提交默认的`commit`

   <img src="../assets/github/image-20220626181012438.png" alt="image-20220626181012438" style="zoom:67%;" />

3. 看一下log记录，可以看到新增了一个记录`Revert 新增C`，并且原来的`新增C`还是在的

   <img src="../assets/github/image-20220626181158337.png" alt="image-20220626181158337" style="zoom:67%;" />



## `git reset` 回退版本

> `reset`命令会把`commit`从历史记录中删除。比如你在`master`分支提交了`A-->B-->C`提交了三个记录，这个时候如果**C记录**有问题你想回退到**B记录**就可以用`git reset`进行。这个命令大概率的情况都是用在我们主分支的，因为我们上线的分支一般是`master`分支然后从`develop`进行功能开发，开发完成之后将分支合并到`master`，如果在上线之前发现合并的分支用问题可以将`develop`合并过来的分支进行回退，说白了就是取消`develop`的本次合并，但是有一种情况就是协作开发的时候大家都合并到`master`之后就不能用`reset`强行回滚`commit`因为这样会把其他人的提交记录给冲掉，这时候就可以用`revert`来进行操作。

`git reset`命令可以回退到之前的某一个提交的状态，他有两个作用：

1. 撤销之前的内容
2. 回退到之前的某一个版本

### `git reset`的三种模式

* `git reset --mixed <commit_hash | HEAD..>`

  > `mixed`参数是该命令的默认参数。
  >
  > 回退到之前的某一个版本，并且只**保留**工作区的修改内容，而**丢弃**暂存区的修改内容。

* `git reset --soft <commit_hash | HEAD..>`

  > 回退到之前的某一个版本，并且**保留**工作区和暂存区的所有修改内容

* `git reset --hard <commit_hash | HEAD..>`

  > 回退到之前的某一个版本，并且**丢弃**工作区和暂存区的所有修改内容

<img src="../assets/github/image-20231230221846274.png" alt="image-20231230221846274" style="zoom:67%;" />

<img src="../assets/github/image-20231230221926128.png" alt="image-20231230221926128" style="zoom:67%;" />



**操作一下reset来感受一下**

1. 在master分支使用`git log`查看commit记录找到B记录，准备回退这一条，回退的时候不需要输入全部的commid一般是前7位就够用

   <img src="../assets/github/image-20220626180505396.png" alt="image-20220626180505396" style="zoom:67%;" />

2. 接着使用`git reset --hard 69fde2c` 或者`git reset --hard HEAD^`进行回滚，这个时候查看log记录发现最后一条`新增c`记录没有了，这里还有个问题如果直接使用`git push origin`推送会有以下提示

   <img src="../assets/github/image-20220626180529631.png" alt="image-20220626180529631" style="zoom:67%;" />

   这是因为本地的记录因为我们的回滚已经落后于仓库的代码了，这个使用需要使用`git push origin -f`进行强制提交

3. 这个时候master分支就剩下A和B的commit记录了，到这里就是一次完整的reset回滚记录，之后我们还是可以继续正常把develop分支合并到master的

   <img src="../assets/github/image-20220626180552658.png" alt="image-20220626180552658" style="zoom:67%;" />



## `git tag` 打版本

> 创建一个tag来指向软件开发中的一个关键时期，比如版本号更新的时候可以建一个`v2.0`、`v3.1`之类的标签，这样在以后回顾的时候会比较方便。tag的使用很简单，主要操作有：查看`tag`、创建`tag`、验证`tag`以及共享`tag`。

### 创建 `tag`

```sh
# 1.创建tag名称为v1.0
$ git tag v1.0

# 2.创建带信息的tag
$ git tag -a v1.0 -m "first version" 
$ git show v1.0 # 查看 tag 相关信息

# 3.创建带签名的tag(前提得有GPG私钥)
$ git tag -s v1.0 -m "first version"
$ git tag -v v1.0 # 验证签署标签

# 4.为以前的commit添加tag
$ git log --oneline # 先查看commit记录
commit：8a5cbc2 updated readme
$ git tag -a v1.1 8a5cbc2 # 为其添加tag

# 5.后期补tag
$ git log --pretty=oneline  # 查看提交记录
$ git tag -a tagName  SHA-1 # 在指定的提交指针处添加 标签
```

### 上传 `tag`

> 在创建`tag`后`git push`，`tag`是不会上传到服务器的，在远程仓库上是看不到tag的，为了共享这些tag，指定tag:

```sh
# 1. 提交指定的tag
$ git push origin v1.0 

# 2. 提交所有未提交的 tag
$ git push origin --tags 
```

### 查看 `tag`

```sh
$ git tag # 列出所有tag，这样列出的tag是按字母排序的，和创建时间没关系

$ git tag -l v1.* # 列出满足条件的 tag
```

### 删除 `tag`

```sh
$ git tag -d v1.0
```

### 验证 `tag`

```sh
$ git tag -v <tag_name> # 在有GPG私钥的前提下验证tag
```



## `git rm` 删除文件

1. 把文件从工作区和暂存区中同时删除

   ```sh
   $ git rm xxx.txt # 把xxx.txt文件从工作区和暂存区中同时删除
   $ git commit -m 'delete xxx.txt' # 提交删除的文件
   ```

2. 把文件从暂存区中删除，但保留在当前工作区中

   ```sh
   $ git rm --cached xxx.txt # 把xxx.txt文件从暂存区中删除
   ```

3. 删除某个目录下的所有文件和目录

   ```sh
   $ git rm -r *
   ```



## `git merge` 合并分支

```sh
$ git switch main # 先切换到要合并的分支上
$ git merge dev # 把dev分支合并到main分支上
```

### 解决合并冲突 `conflict`

打开冲突文件来查看具体冲突内容

```shell
# GitTest
For git command practice

<<<<<<< HEAD
chagne README file on the main branch //内容1
=======
do something on develop branch //内容2

>>>>>>> develop
```

冲突的内容会被`<<<<<<<`与`>>>>>>>`所包围，中间用`=======`隔离开，也就如我所注释的分成了`内容1`与`内容2`两块。

- `内容1`：是当前所在分支节点的内容，也就是`main`。
- `内容2`：要合并进来分支的内容，也就是`develop`。

选择你要的内容，将`<<<<<<<`、`>>>>>>>`、`=======`这些隔离符删除掉，并保存，然后执行`git add`、`git commit`完成合并。

## `git diff` 比较差异

### 1. 查看工作区、暂存区、本地仓库之间的差异

```sh
$ git diff # 默认比较工作区和暂存区之间的差异内容.
$ git diff HEAD # 比较工作区和本地仓库之间的差异内容
$ git diff --cached # 比较暂存区和本地仓库之间的差异内容. cached也可以改成staged
```

### 2. 查看不同版本之间的差异

```sh
$ git diff <commit_hash_1> <commit_hash_2> # 比较两个特定版本之间的内容
$ git diff HEAD~ HEAD # 比较上一个版本和当前版本之间的差异。HEAD~等同于HEAD^表示上一个版本
$ git diff HEAD^3 HEAD # 比较之前第三个版本和当前版本之间的差异
$ git diff HEAD^3 HEAD xxx.txt # 比较之前第三个版本和当前版本中xxx.txt文件之间的差异
```

### 3. 查看不同分支之间的差异

```sh
$ git diff <branch_name1> <branch_name2>
```



> 这些命令将在终端内打开差异视图，但如果你更喜欢使用更直观的工具来比较差异的话，不妨试试`git difftool`。`Meld`是一款不错的查看器/编辑器，可用于直观地比较差异。

配置`Meld`：

```shell
$ git config --global diff.tool git-meld
```

查看差异:

```shell
$ git difftool $start_commit..$end_commit -- path/to/file
# 或者
$ git difftool $start_commit..$end_commit
```



## `git blame` 查看谁更改了文件中某一行代码

```sh
$ git blame -w  # ignores white space

$ git blame -M  # ignores moving text

$ git blame -C  # ignores moving text into other files
```



## 其他

### 删除已从远程移除的本地分支

本地存储库中可能存在已经失效的分支。要在每次`fetch/pull`时删除这些远程存储库中已不再存在的分支，请运行：

```shell
$ git config --global fetch.prune true
```

或者手动将以下内容添加到`~/.gitconfig`中：

```
[fetch]
  prune = true
```

### `HEAD `的别名

`@`与`HEAD`相同。在`rebase`期间使用`@`可以帮上大忙：

```shell
$ git rebase -i @~2
```

### 撤销修改

#### 方式一

> 当你在修改代码时，突然意识到所做的更改不是很好，并且想要重置这些更改时，你可以将文件重置为分支的`HEAD`，而非单击撤消你编辑的所有内容。

```shell
git reset --hard HEAD
```

如果你要重置单个文件：

```shell
git checkout HEAD -- path/to/file
```

如果你已经提交了更改，但仍想恢复，可以使用：

```shell
git reset --soft HEAD~1
```

#### 方式二

> 撤回文件

```shell
git restore [file path]
```

